#line 2 "src/Gui/AccountRegister.h"

#ifndef __GUI_ACCOUNTREGISTER_H___
#define __GUI_ACCOUNTREGISTER_H___

#include <Wt/Json/Object.h>
#include <Wt/WBatchEditProxyModel.h>
#include <Wt/WContainerWidget.h>
#include <Wt/WSortFilterProxyModel.h>
#include <Wt/WStandardItem.h>
#include <Wt/WStandardItemModel.h>
#include <Wt/WItemDelegate.h>
#include <Wt/WPopupMenu.h>

#include "../GnuCashew.h"
#include "../Eng/AccountRegisterModel.h"
#include "TableView.h"


namespace GCW {

  // FIXME
  // not sure why I need to forward-declare this class... it's
  //  right up there in the header
  namespace Eng { class AccountRegisterModel; }

  namespace Gui {

/*!
** \brief AccountRegister
**
** The AccountRegister is a widget that displays transactions from a single account
**  within the system.  It displays the account transactions in a spreadsheet-table-like
**  format with multiple columns representing other field values such as;
**  date, check-number, description... and so on.
**
** \image html AccountRegister.png "Account Register" width=480
**
** The goal here is to make this widget behave just as closely as possible to the
**  GnuCash interface, because theirs is very slick and makes navigating the register
**  a no-mouse-necessary affair.  One of the problems with web-based interfaces, however,
**  is trapping keys completely, such as the ~tab~ key.  So... we'll see how this
**  goes!
**
** The register view also grants the user editing abilities.  When the user clicks on
**  fields that are ~not~ reconciled, and appropriate 'editor' will open.  The editor
**  depends on the column selected, and is generated by the column Delegates.
*/
class AccountRegister
: public Wt::WContainerWidget
{
  private:

    /*!
    ** \brief Base Delegate
    **
    ** This class is strictly for debugging and tracing purposes.  It
    **  facilitates the hooking of the various calls in to the delegate
    **  classes so that their behaviour and interaction with the view
    **  can be studied, understood (and perhaps documented).
    **
    */
    class BaseDelegate
    : public Wt::WItemDelegate
    {
      public:

        BaseDelegate();
       ~BaseDelegate();
        virtual auto update( Wt::WWidget * _widget, const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags )-> std::unique_ptr< Wt::WWidget > ;
        virtual auto updateModelIndex( Wt::WWidget * _widget, const Wt::WModelIndex & _index )-> void ;
        virtual auto validate( const Wt::WModelIndex & _index, const Wt::cpp17::any & _editState ) const-> Wt::ValidationState ;
        virtual auto editState( Wt::WWidget * _widget, const Wt::WModelIndex & _index ) const-> Wt::cpp17::any ;
        virtual auto setEditState( Wt::WWidget * _widget, const Wt::WModelIndex & _index, const Wt::cpp17::any & _value ) const-> void ;
        virtual auto setModelData( const Wt::cpp17::any & _editState, Wt::WAbstractItemModel * _model, const Wt::WModelIndex & _index ) const-> void ;

    }; // endclass BaseDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    class HeaderDelegate
    : public BaseDelegate
    {
      public:

        HeaderDelegate();
       ~HeaderDelegate();
        auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;
        virtual auto editState( Wt::WWidget *_editor, const Wt::WModelIndex &_index ) const-> Wt::cpp17::any override ;

    }; // endclass HeaderDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    /*!
    ** \brief Date Delegate
    **
    ** The date delegate handles the WDateTime value from the model.
    **  Even though a 'transaction' is posted on a 'date' and not
    **  particularly a time, the gnucash system still is sensitive
    **  to time values in date-only fields.  In the case of the
    **  transactions, the 'time' component is set to 10:59:00.  There
    **  is a macro that contains this value 'GCW_DATE_DEFAULT_TIME'
    **  which should be used to reference the correct time-value.
    **  The time-component is important since when reading items out
    **  of the database, gnucash responds poorly to posted dates that
    **  have a 00:00:00 time component set, it must be set to the
    **  10:59:00 value.
    **
    */
    class DateDelegate
    : public BaseDelegate
    {
      public:

        DateDelegate();
       ~DateDelegate();
        virtual auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;

        /*!
        ** \brief Edit State
        **
        ** A thing about editState, setEditState, setModelData.  Each of these use 'cpp17::any' data
        **  for handling data.  When you 'editState' you can return anything you want that will also
        **  be digested by 'setEditState'.  Then, also, therefore, setModelData will also receive
        **  anything from 'editState'.  So, this can be a handy tool for passing around different
        **  editor info that is specifically tied to a row or item that is being edited.  Right now
        **  we just return the date value, since that's what we're using and poking straight in to the
        **  model and what not, but we could be passing around any object/date/type... just sayin.
        */
        virtual auto editState( Wt::WWidget * _editor, const Wt::WModelIndex & _index ) const-> Wt::cpp17::any override ;
        virtual auto setEditState( Wt::WWidget * _editor, const Wt::WModelIndex & _index, const Wt::cpp17::any & _value ) const-> void ;
        virtual auto setModelData ( const Wt::cpp17::any & _editState, Wt::WAbstractItemModel * _model, const Wt::WModelIndex & _index ) const-> void ;

        auto doCloseEditor( Wt::WDateEdit * _dateEdit, bool _save ) const-> void ;
        auto doTabAction( Wt::WKeyEvent _keyEvent ) const-> void ;

      private:

        auto setDate( Wt::cpp17::any _value ) const-> void ;

        mutable Wt::WDateEdit * m_dateEdit = nullptr;

    }; // endclass DateDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    class ReconcileDelegate
    : public BaseDelegate
    {
      public:

        ReconcileDelegate();
       ~ReconcileDelegate();
        virtual auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;
        virtual auto editState( Wt::WWidget * _editor, const Wt::WModelIndex & _index ) const-> Wt::cpp17::any override ;
        virtual auto setEditState( Wt::WWidget * _editor, const Wt::WModelIndex & _index, const Wt::cpp17::any & _value ) const-> void ;
        virtual auto setModelData ( const Wt::cpp17::any & _editState, Wt::WAbstractItemModel * _model, const Wt::WModelIndex & _index ) const-> void ;

        virtual auto doCloseEditor( Wt::WLineEdit * _editor, bool _save ) const-> void ;
        virtual auto doTabAction( Wt::WKeyEvent _keyEvent ) const-> void ;

    }; // endclass ReconcileDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    class ValueDelegate
    : public BaseDelegate
    {
      public:

        ValueDelegate();
       ~ValueDelegate();

        virtual auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;

    }; // endclass ValueDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    /*
    ** Balance delegate works just like the ValueDelegate but
    **  also adds a read-only attribute to the input, so it
    **  displays the same, but cannot be edited.  This is done
    **  so that the entire line is highlighted fully when
    **  selected.
    **
    */
    class BalanceDelegate
      : public BaseDelegate
    {
      public:

        BalanceDelegate();
       ~BalanceDelegate();

        auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;

    }; // endclass BalanceDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    class SuggestionDelegate
    : public BaseDelegate
    {
      public:

        SuggestionDelegate();
       ~SuggestionDelegate();
        virtual auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;

    }; // endclass SuggestionDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    class AccountDelegate
      : public BaseDelegate
    {
      public:

        AccountDelegate();
       ~AccountDelegate();
        virtual auto createEditor( const Wt::WModelIndex & _index, Wt::WFlags< Wt::ViewItemRenderFlag > _flags ) const-> std::unique_ptr< Wt::WWidget > ;

    }; // endclass AccountDelegate

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

    /*!
    ** The status-bar presents various totals from the register,
    **  including the rowCount().
    */
    class StatusBar
    : public Wt::WContainerWidget
    {
      public:
        StatusBar();

        auto setPresent   ( GCW_NUMERIC _value = GCW_NUMERIC(0) )-> void ;
        auto setFuture    ( GCW_NUMERIC _value = GCW_NUMERIC(0) )-> void ;
        auto setCleared   ( GCW_NUMERIC _value = GCW_NUMERIC(0) )-> void ;
        auto setReconciled( GCW_NUMERIC _value = GCW_NUMERIC(0) )-> void ;
        auto setProjected ( GCW_NUMERIC _value = GCW_NUMERIC(0) )-> void ;
        auto setRowCount  ( int         _value = 0              )-> void ;

      private:

        Wt::WText * m_present    = nullptr ;
        Wt::WText * m_future     = nullptr ;
        Wt::WText * m_cleared    = nullptr ;
        Wt::WText * m_reconciled = nullptr ;
        Wt::WText * m_projected  = nullptr ;
        Wt::WText * m_rowCount   = nullptr ;

    }; // endclass StatusBar

    /* * * * * * * * * * * * * * * * * * * * * * * * * * */

  public:

    /*!
    ** \brief Model
    **
    ** An alias for the Model in case this interface changes.
    */
    using BaseModel       = GCW::Eng::AccountRegisterModel ;
    using SortFilterModel = Wt::WSortFilterProxyModel ;
    using BatchEditModel  = Wt::WBatchEditProxyModel ;

    /*!
    ** \brief Constructor
    **
    ** A register must be opened to a specific AccountGuid.  If the AccountGuid
    **  is blank or cannot be found (why would that be?) then the register simply
    **  opens, allows registry entries, but has no place to save them (dangerous?).
    */
    AccountRegister( const std::string & _accountGuid = "" );

    /*!
    ** \brief Set Account
    **
    ** This sets the GUD of the account being represented by this
    **  view
    */
    auto setAccountGuid( const std::string & _accountGuid )-> void ;

    /*!
    ** \brief Table View
    */
    auto tableView ()-> GCW::Gui::TableView * { return m_tableView; }

    auto baseModel       ()-> std::shared_ptr< BaseModel       >  { return m_baseModel;       }
    auto sortFilterModel ()-> std::shared_ptr< SortFilterModel >  { return m_sortFilterModel; }
    auto batchEditModel  ()-> std::shared_ptr< BatchEditModel  >  { return m_batchEditModel;  }

    /*!
    ** \brief Status Bar
    **
    ** This returns a pointer to the status bar
    */
    auto statusBar()-> StatusBar * { return m_statusBar; }

    auto test()-> void ;

    /*!
    ** \brief Set Read Only
    **
    ** This makes the register view read-only
    */
    auto setReadOnly( bool _state = true )-> void ;

    /*!
    ** \brief Create View Properties JSON Object
    **
    ** This will pack all of the Widget display variables in to a JSON
    **  object for restoration later.
    **
    ** \sa fromJson()
    */
    auto toJson() const-> Wt::Json::Object ;

    /*!
    ** \brief Set View Properties from JSON Object
    **
    ** This accepts a JSON object containing all of the view properties
    **  and applys them to the view, essentially restoring it
    **  to its previous layout.
    */
    auto fromJson( const Wt::Json::Object & _jobj )-> bool ;

  private:

    /*!
    ** \brief Load the Data
    **
    ** This loads all of the transactions in to the register.
    */
    auto loadData()-> void ;

    /*!
    ** \brief Select Row
    **
    ** This selects the row based on it's row number.
    */
    auto do_selectRow( Wt::WModelIndex _index )-> void ;

    /*!
    ** \brief Edit Row
    **
    ** This edits the row based on it's row number.
    */
    auto editRow( Wt::WModelIndex _index )-> void ;


    /*!
    ** \brief Delete Row
    **
    ** This Deletes a row based on it's row number.
    */
    auto deleteRow( int _row )-> void ;

    /*!
    ** \brief Last Index
    **
    ** This returns the last index in the model.
    */
    auto lastIndex()-> Wt::WModelIndex ;

    /*!
    ** \brief Show Popup
    **
    ** This responds to a mouse-right-click within the table view.
    **  When triggered, this will pop-up an environment-sensitive
    **  menu that the user can choose actions from.  The context
    **  sensitivity is driven by the type of item that is on the
    **  row that the cursor was on with the click event was
    **  triggered.
    */
    auto on_showPopup_triggered( const Wt::WModelIndex & _index, const Wt::WMouseEvent & _event )-> void ;

    auto on_sortBy_triggered()-> void ;
    auto on_filterBy_triggered()-> void ;
    auto on_renamePage_triggered()-> void ;
    auto on_duplicate_triggered()-> void ;

    /*!
    ** \brief Delete a Row
    **
    ** This will delete a row from the register
    */
    auto on_delete_triggered()-> void ;

    /*!
    ** \brief Remove Splits
    **
    ** This will remove the splits from the transaction
    */
    auto on_removeSplits_triggered()-> void ;

    /*!
    ** \brief Enter Transaction
    **
    ** This will enter the transaction, just like if the user
    **  hit the ENTER key
    */
    auto on_enter_triggered()-> void ;

    /*!
    ** \brief Cancel Transaction
    **
    ** This will cancel the edits on the transaction.  This
    **  would be the same if the user hit the <esc> key
    */
    auto on_cancel_triggered()-> void ;

    /*!
    ** \brief Manage Document
    **
    ** This opens a dialog that allows the user to attach
    **  a document to the transaction
    */
    auto on_manageDocument_triggered()-> void ;

    /*!
    ** \brief Open Document
    **
    ** This allows the user to open the document attached
    **  to the transaction
    */
    auto on_openDocument_triggered()-> void ;

    /*!
    ** \brief Blank Transaction
    **
    ** This will blank all the values in a transaction
    */
    auto on_blankTransaction_triggered()-> void ;

    /*!
    ** \brief Go to Date
    **
    ** This will jump to a specific date within the register view
    */
    auto on_goDate_triggered()-> void ;

    /*!
    ** \brief Split Transaction
    **
    ** This will split the current transaction
    */
    auto on_splitTransaction_triggered()-> void ;

    /*!
    ** \brief Edit Exchange Rate
    **
    ** This will edit the exchange rate on the transaction
    */
    auto on_editExchangeRate_triggered()-> void ;

    /*!
    ** \brief Schedule a Transaction
    **
    ** This will set up a scheduled transaction
    */
    auto on_schedule_triggered()-> void ;

    /*!
    ** \brief Jump to Transaction
    **
    ** This will jump to the other side of the transaction
    */
    auto on_jump_triggered()-> void ;

    /*!
    ** \brief Assign Payment
    **
    ** This allows the transaction to be assigned
    **  as a payment to an invoice
    */
    auto on_assignPayment_triggered()-> void ;

    /*!
    ** \brief Clicked Handler
    **
    ** This captures clicks within the table view
    */
    auto on_tableView_clicked( Wt::WModelIndex _index, Wt::WMouseEvent _event )-> void ;

    /*!
    ** \brief Delegate Handles
    **
    ** Here we're going to hold on to the Delegate handles so
    **  we can interact with the UI a little bit
    */
    std::shared_ptr< DateDelegate       > m_delegateDate ; // 0() );
    std::shared_ptr< SuggestionDelegate > m_delegateNum  ; // 1() );
    std::shared_ptr< SuggestionDelegate > m_delegateMemo ; // 2() );
    std::shared_ptr< AccountDelegate    > m_delegateAcct ; // 3() );
    std::shared_ptr< ReconcileDelegate  > m_delegateReco ; // 4() );
    std::shared_ptr< ValueDelegate      > m_delegateIn   ; // 5() );
    std::shared_ptr< ValueDelegate      > m_delegateOut  ; // 6() );
    std::shared_ptr< BalanceDelegate    > m_delegateBal  ; // 7() );

    Wt::WPopupMenu                                 m_popupMenu               ;
    std::string                                    m_accountGuid             ;
    std::shared_ptr< BaseModel                 >   m_baseModel               ;
    std::shared_ptr< Wt::WSortFilterProxyModel >   m_sortFilterModel         ;
    std::shared_ptr< Wt::WBatchEditProxyModel  >   m_batchEditModel          ;
    GCW::Gui::TableView                          * m_tableView     = nullptr ;
    StatusBar                                    * m_statusBar     = nullptr ;
    Wt::WModelIndex                                m_selectIndex             ;
    Wt::WModelIndex                                m_clickedIndex            ;
    Wt::WModelIndex                                m_rightClickIndex         ;

};  // endclass AccountRegister

  } // endnamespace Gui {
} // endnamespace GCW {

#endif // end __GUI_ACCOUNTREGISTER_H___


